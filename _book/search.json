[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Palaeoecological data-science: a data driven curriculum",
    "section": "",
    "text": "1 Introduction\nWelcome to palaeoecological data-science! This book is designed as a reproducible workflow for a semester-long course in palaeoecological data-science with the accompany publication XXX. For students, the book is carefully designed as both an educational resource with working examples and exercises, and as a coding resource that can be transferred to your own analyses. The cautionary note being that the most appropriate analyses (e.g., NMDS or GAMs?), or parameterisation of the analyses will likely be different for your data. To help, the key resources associated with each analytical method are cited throughout. Some R knowledge is assumed but we have tried to make it as easy-to-follow as possible with reproducible, working code chunks.\nFor instructors, the repository can be forked and edited to suit different needs. The pollen data from Devil’s Lake (Wisconsin, USA) used as an example dataset can be swapped out for a different region or proxy (e.g., diatoms) and the workflow edited to accommodate for the change. We would love to know how the resource is adapted and used so drop us an email and let us know!\nIf you do use this resource for teaching or learning please cite it: DOI XXX. This will help us keep track of the impact and use of such open-source curricula and inform future work.\nThis curriculum is an open-source and we welcome suggestions for improvement from the community that will be reviewed by the developers. We will also keep the resource up-to-date with the latest package improvements. The development of this curriculum is tracked with version control using git and the renv package is used to control package versions. section perhaps should be edited and moved to readme with instructions for raising github issues"
  },
  {
    "objectID": "index.html#what-this-book-is",
    "href": "index.html#what-this-book-is",
    "title": "Palaeoecological data-science: a data driven curriculum",
    "section": "1.1 What this book is",
    "text": "1.1 What this book is\nMany palaeo research projects follow the same general workflow, of course there will always be unique questions, challenges, and additional interests. This book is intended to cover the general workflow from obtaining data, through wrangling, analysing and visualising. There are examples throughout"
  },
  {
    "objectID": "index.html#what-this-book-is-not",
    "href": "index.html#what-this-book-is-not",
    "title": "Palaeoecological data-science: a data driven curriculum",
    "section": "1.2 What this book is not",
    "text": "1.2 What this book is not\nPalaeo-science comprise many disciplines from biochemistry and climatology, to mathematics, and ecology. We focus on providing a workflow but cannot, in detail, cover every challenge faced in, for example, age-depth modelling or statistical analyses of proxies. To remedy this shortcoming, each section has the key references that, while not essential for this book, are a starting point to understanding essential challenges."
  },
  {
    "objectID": "index.html#is-this-going-to-hurt",
    "href": "index.html#is-this-going-to-hurt",
    "title": "Palaeoecological data-science: a data driven curriculum",
    "section": "1.3 Is this going to hurt?",
    "text": "1.3 Is this going to hurt?\nYes. But it will be worth it. Palaeoecological data are complex and demand advanced analyses and modelling methods that require anything from basic coding proficiency and a laptop, to super-computing resources and online databases.\n\nSet up group Zotero\nComplete writing\nComplete YAML file\nAuthor order? Authors per chapter?\nrenv\nreplace PSM with LDA?\nhost and track with google analytics?\ncheck literature is open access?"
  },
  {
    "objectID": "01-intro.html#lab-overview",
    "href": "01-intro.html#lab-overview",
    "title": "2  Neotoma Explorer",
    "section": "2.1 Lab overview",
    "text": "2.1 Lab overview\nThis lab is designed to introduce you to the Neotoma Paleoecology Database and Neotoma Explorer. Neotoma DB is an open and community-curated resource for paleoecological data. Open means that anyone can find and download data from Neotoma. Community-curated means that Neotoma data are augmented and maintained by a community of experts, with many scientists contributing their data to Neotoma and actively working to curate and improve these data. Explorer is a graphical interface that is very handy for a first-pass search, discovery, and viewing of paleoecological data, typically exploring a few sites at a time. In following weeks, we will move to more advanced visualizations and analyses of paleoecological data, using software designed to download data from Neotoma and analyze it."
  },
  {
    "objectID": "02-intro-to-R.html#a-necessary-evil",
    "href": "02-intro-to-R.html#a-necessary-evil",
    "title": "3  Intro to R",
    "section": "3.1 A necessary evil",
    "text": "3.1 A necessary evil\nThis course assumes a degree of knowledge of the R language (e.g., packages and data structures), and principles of tidy data (e.g., long and wide data format). We include detailed comments in the code, but do not attempt to provide a complete introduction to R. We include pointers to exceptional resources for learning R basics should you need them:\nFree books by Roger Peng and Hadley Wickham\n\n(Telford biostats, environmental computing)"
  },
  {
    "objectID": "02-intro-to-R.html#r-gui",
    "href": "02-intro-to-R.html#r-gui",
    "title": "3  Intro to R",
    "section": "3.2 R GUI",
    "text": "3.2 R GUI\nRStudio and VS Code"
  },
  {
    "objectID": "02-intro-to-R.html#r-projects",
    "href": "02-intro-to-R.html#r-projects",
    "title": "3  Intro to R",
    "section": "3.3 R projects",
    "text": "3.3 R projects\nR projects are not essential to use but can make life a little easier"
  },
  {
    "objectID": "02-intro-to-R.html#directory-structure",
    "href": "02-intro-to-R.html#directory-structure",
    "title": "3  Intro to R",
    "section": "3.4 Directory structure",
    "text": "3.4 Directory structure\nHaving a well structured project directory is important for accessing the files you need and for reproducibility."
  },
  {
    "objectID": "02-intro-to-R.html#version-control",
    "href": "02-intro-to-R.html#version-control",
    "title": "3  Intro to R",
    "section": "3.5 Version control",
    "text": "3.5 Version control\nIt is good practice to back-up your data and use version control for your code. Onve you integrate version control into your workflow you will wonder how you ever lived without it. Version control is a vast subject but knowing the basics can get you a very far. The Git language (not to be confused with GitHub the remote server) is a common method used to colaborate in software development. Git is not a pre-requisite for this book but as a necessary part of an advanced workflow we include some links to learning basic version control:\n\nlinks…\n\nAs an example, this book itself is version controlled and collaborated on using Git and GitHub, the resources can be found here-LINK"
  },
  {
    "objectID": "02-intro-to-R.html#packages",
    "href": "02-intro-to-R.html#packages",
    "title": "3  Intro to R",
    "section": "3.6 Packages",
    "text": "3.6 Packages\nR is equiped with packages for data wrangling aside from the BASE R language, notably data.table and several packages inside the tidyverse library. We won’t debate the differences here. We will primarily use packages from the tidyverse (dplyr, ggplot2...) because they integrate with theneotoma2` package used for interacting with the Neotoma(link) API."
  },
  {
    "objectID": "02-intro-to-R.html#packages-used-in-this-book",
    "href": "02-intro-to-R.html#packages-used-in-this-book",
    "title": "3  Intro to R",
    "section": "3.7 Packages used in this book",
    "text": "3.7 Packages used in this book\nThe following packages are required for this book. Run the following code to install them all (installation might take a few minutes!).\nmore to come, mgcv, pca packages…..\n\nif (!require(\"pacman\")) install.packages(\"pacman\", repos=\"http://cran.r-project.org\")\npacman::p_load(tidyverse, neotoma2, Bchron)    # Install & load packages"
  },
  {
    "objectID": "03-age-depth-modelling.html#part-1-background",
    "href": "03-age-depth-modelling.html#part-1-background",
    "title": "4  Age-depth modelling",
    "section": "4.1 Part 1: Background",
    "text": "4.1 Part 1: Background\nA foundational difference between geology and ecology is that, for geologists, time is an unknown variable that must be estimated with uncertainty. In contrast, most ecologists can assume that the temporal coordinates of their observations are known precisely, with zero uncertainty. Fortunately, geochronologists have a wide variety of natural clocks, thanks to the constant decay rates of radioactive isotopes. Each isotope has a unique decay rate, and so each is appropriate for particular timescales.\nFor the last 50,000 years, radiocarbon (14C), with its half-life of 5,730 years, is by far the most common form of radiometric dating. (Beyond 10 half-lives, so much of a radioactive substance has decayed away that it becomes immeasurable.) Radiocarbon is the mainstay of Quaternary dating and archaeology.\nIn Quaternary paleoecology, radiocarbon dating is expensive – a single sample typically costs $300 to $500 – so usually a given lake-sediment record will have only a scattering (ca. 5 to 30) of radiocarbon dates and other age controls. Other kinds of age controls include volcanic ash layers (tephras), 210Pb (half-life: 22.6 yrs), optically stimulated luminescence (OSL) dates, historic events such as the rise in Ambrosia pollen abundances associated with EuroAmerican land clearance, etc. An age-depth model must be constructed to estimate the age of sediments not directly associated with an age control. In multi-site data syntheses, the number of age controls, their precision, and their likely accuracy are all fundamental indicators of data quality (e.g. Blois et al. 2011; Mottl et al. 2021).\nTo estimate ages for depths lacking radiocarbon date, an age-depth model is required. Age-depth models are fitted to the available age controls (age estimates with uncertainty for individual depths) and provide estimates of age as a function of depth, for all depths and ages within the temporal bounds of the model.\nHere we will gain practice in working with age-depth models of various kind, and assessing their age estimates and uncertainty. We’ll begin with a bit of practice in calibrating radiocarbon years to calendar years and comparing the resulting age estimates from different calibration curves.\n\n\n\n\n\n\nPackages required for this section\n\n\n\nWe will be using Bchron for calibration and Bayesian age-depth modelling. Notably rbacon is another commonly used package, see Trachsel and Telford (2017) for a discussion on age-depth models. We will also be fitting some interpolation and linear models using BASE-R.\n\n# Load up the package\nlibrary(Bchron)\nlibrary(splines) # for fitting splines comes with Base-R\n\n\n\n\n4.1.1 Calibration of Radiocarbon Dates\nA complication in radiocarbon dating is that the initial calculation of a radiocarbon age assumes, by convention, that the amount of radiocarbon in the atmosphere is constant over time. See Bronk Ramsey (2008) for a good overview of 14C dating. This assumption is untrue, so all radiocarbon age estimates must be post-hoc calibrated using a calibration curve that is based on compiling radiocarbon dates of materials that have precise independent age estimates (e.g. tree rings, corals). The IntCal series (IntCal04, IntCal09, IntCal13, IntCal20) is the community standard for calibrating radiocarbon dates to age estimates in calendar years (e.g., Reimer et al. 2020). The conversion from radiocarbon to calendar years usually further increases the uncertainty of age estimates.\nYet another complication in radiocarbon dating is that different calibration curves need to be used for the Northern vs. Southern Hemisphere and for the atmosphere vs. oceans, due to different residence times of 14C in these different reservoirs. For example, atmospheric radiocarbon that diffuses into the surface oceans usually will reside for centuries before phytoplankton biologically fix it through photosynthesis, which will lead marine 14C to be depleted (and ‘too old’) relative to atmospheric 14C. Use the wrong calibration curve and your age estimate will be inaccurate!\n\n4.1.1.1 Calibrating radiocarbon dates in R\nHere we’ll experiment with calibrating radiocarbon dates, using various calibration curves. Radiocarbon dated samples come back from the lab with a radiocarbon age and standard deviation, among other information. These two bits of information are used to calibrate the radiocarbon dates to estimated ages. R packages may have useful vignettes (package tutorials) and built-in datasets that provide handy test templates. The following code is modified from the Bchron vignette.\n\nCodeSummaryPlotsCalibration curve plots\n\n\n\nages = BchronCalibrate(ages=c(3445,11553,7456), \n                        ageSds=c(50,230,110), \n                        calCurves=c('intcal20','intcal20','intcal20'))\n\n\n\n\nsummary(ages)\n\n95% Highest density regions for Date1\n$`94.4%`\n[1] 3572 3834\n\n\n95% Highest density regions for Date2\n$`0.4%`\n[1] 13004 13025\n\n$`77.9%`\n[1] 13059 13874\n\n$`16.4%`\n[1] 13923 14012\n\n\n95% Highest density regions for Date3\n$`94.6%`\n[1] 8022 8423\n\n\n\n\n\nplot(ages)\n\n[[1]]\n\n\n\n\n\n\n[[2]]\n\n\n\n\n\n\n[[3]]\n\n\n\n\n\n\n\n\nplot(ages, includeCal = TRUE, fillCol = 'red')\n\n\n\n\n\n\n\nThe output summary indicates the range of the highest density regions (i.e., the most likely ‘real’ age range of the sample). The plot function in Bchron outputs a ggplot object of the high density regions of the most likely ages.\n\n\n\n4.1.2 Types of Age-Depth Models\nDifferent kinds of age-depth models exist, each with their own underlying assumptions and behavior. In the list below, #1-4 are classical or traditional forms of age-depth models, but Bayesian models are now the norm. The packages rbacon (usually referred to as ‘bacon’) and Bchron are the current standards for Bayesian age-depth modelling. Before going to bayesian models, we’ll begin with the classics.\n\nLinear interpolation, a.k.a. ‘connect the dots,’ in which straight lines are drawn between each depth-adjacent pair of age controls.\nLinear regression (\\(y=b0~ + b1x\\); \\(y=\\)time and \\(x=\\)depth; \\(b0\\) and \\(b1\\) are constants), in which a single straight line is fitted through the entire set of age controls. In ordinary linear regression (OLS), the chosen line will minimize the y-dimension distances of individual points to the line. Standard OLS assumes that all observations are normally distributed, which is a poor assumption for calibrated radiocarbon dates.\nPolynomials, also fitted to the entire set of age controls (\\(y= b0 + b1x + b2x^2 + b3x^3 + …bnx^n\\)), are an extension of linear regression, with additional terms for \\(x^2\\), \\(x^3\\), etc. Some arbitrary maximum n is chosen, usually in the range of 3 to 5. These are called ‘third-order polynomials,’ ‘fifth-order polynomials,’ etc.\nSplines, which are a special kind of polynomial function that are locally fitted to subsets of the age controls, and then smoothly interpolated between points. (Several different formulas can be used to generate splines; common forms include cubic, smooth, monotonic, and LOWESS).\nBayesian age models (e.g. bacon, bchron, oxcal, etc.). Bayesian models differ in detail, but all combine a statistical representation of prior knowledge with the new data (i.e. the age controls at a site) to build an age-depth model with posterior estimates of age for any given depth. Bayesian models are now widely used because\n\nthey allow the incorporation of prior knowledge (e.g., from coring many lakes, we now have decent estimates of typical sediment accumulation rates, Goring et al. (2012));\nthey can handle highly irregular probability distribution functions such as those for radiocarbon dates after calibration; and as a result\nthey generally do a better job of describing uncertainty than traditional age-depth models.\n\n\n\n4.1.2.1 Classical age-depth models\nClassical models are now out-dated methods (Blaauw et al. 2018), but it is useful to understand how they work as literature before the relatively recent development of Bayesian methods has relied on them. Let’s explore some classical methods of age-depth modelling using one of the datasets included with the Bchron package. The data are from a core in Northern Ireland; Sluggan Bog Smith and Goddard (1991), and can be called via:\n\ndata(Sluggan) # Call the data from Bchron\nprint(Sluggan) # Check out the data\n\n\nLinear interpolationLinear regressionPolynomial regressionCubic splines\n\n\nLinear interpolation predicts ages by simply, drawing a line between successive dated samples. This method assumes that there is a constant age-depth relationship between samples. An assumption that is unlikely to be true, especially of cores with fewer dated samples than Sluggan Moss.\n\ninterp_ages <- approx(x = Sluggan$ages, y = Sluggan$position) # use the function approx() to interpolate between ages\nplot(x = interp_ages$x, y = interp_ages$y, type = 'l') # Plot the interpolated data\npoints(x = Sluggan$ages, y = Sluggan$position, cex = 1.5, col = 'red') # overlay the original age points\n\n\n\n\n\n\nLinear regression provides a line of best fit through the dated samples. This method assumes a constant age-depth relationship across all samples, also unlikely to be true depending on processes affecting the core during its formation.\n\nmod_ages <- lm(Sluggan$position ~ Sluggan$ages) # Create a linear regression model\nplot(x = Sluggan$ages, y = Sluggan$position, cex = 1.5, col = 'red') # Plot the original ages\nabline(mod_ages) # add the regression line from the regression model\n\n\n\n\n\n\nPolynomial regression allows a curve to be fit through the data. The amount the curve ‘wiggles’ depends on the order of the polynomial fit to the data. Polynomial regression has the risk of being over-fit.\n\nx <- Sluggan$ages # Renaming the variables because the predict function below is fussy about the input name\ny <- Sluggan$position\npoly_ages <- lm(y ~ poly(x, 3))\n\nplot(x = Sluggan$ages, y = Sluggan$position, cex = 1.5, col = 'red')\nage_range <- seq(from = range(Sluggan$ages)[1], to = range(Sluggan$ages)[2], length.out = 250)\nlines(age_range, predict(poly_ages, data.frame(x = age_range)))\n\n\n\n\n\n\nSplines are a class of functions including, for example, smoothing splines or cubic splines. Cubic splines are pieve-wise polynomials locally between ‘knots’. That is the data are split into bins that are fit independently using. By default, the bs() function uses a third degree polynomial. Without providing knots the fit will look the same as a third degree polynomial regression.\n\ncubic_ages <- lm(y ~ bs(x, knots = c(1000, 6000, 12000)))\nplot(x = Sluggan$ages, y = Sluggan$position, cex = 1.5, col = 'red')\nlines(age_range, predict(cubic_ages, data.frame(x = age_range)))\n\n\n\n\n\n\n\nBecause classical age-depth modelling is rarely used now we are not going to delve further into the statistical details of the best way of fitting each model (e.g., the number of knots to use for fitting a cubic spline).\nOne of the issues with classical age-depth modelling is that uncertainty decreases with fewer datapoints.\n\n\n4.1.2.2 Bayesian age-depth models\nNow let’s see what the latest methods show for the same dataset.\n\nCodeSummaryPlot\n\n\nNote that all the values provided to the arguments are contained in the Sluggan dataframe. When creating chronologies from your own (or accessed data), you may need to rename them to match your data.\n\nSlugganOut = with(Sluggan, \n               Bchronology(ages=ages,\n                           ageSds=ageSds, \n                           calCurves=calCurves,\n                           positions=position, \n                           positionThicknesses=thickness,\n                           ids=id, \n                           predictPositions=seq(0,518, by=10)))\n\n\n\nThe summary shows for each position (depth) the median and quartiles of the predicted ages for that position.\n\nsummary(SlugganOut)\n\nQuantiles of predicted ages by depth: \n Depth      2.5%      25%     50%      75%     97.5%\n     0   -62.000    75.00   213.0   390.00   692.025\n    10    25.925   225.75   372.0   518.25   767.100\n    20   147.700   375.75   513.0   638.00   812.200\n    30   268.975   527.00   648.5   741.00   872.050\n    40   491.950   716.00   784.0   843.00   927.050\n    50   964.975  1067.00  1130.0  1195.00  1306.000\n    60  1147.925  1266.00  1327.0  1394.00  1522.100\n    70  1397.875  1485.00  1544.0  1609.00  1783.025\n    80  1500.000  1641.75  1732.0  1842.00  2035.025\n    90  1618.000  1801.00  1904.5  1989.00  2172.000\n   100  1832.975  2005.00  2076.5  2164.00  2275.025\n   110  2156.975  2347.75  2474.0  2622.00  2906.100\n   120  2377.925  2704.50  2844.5  2949.00  3121.025\n   130  2969.900  3156.00  3268.0  3398.00  3718.075\n   140  3134.975  3387.75  3554.0  3739.00  4046.225\n   150  3282.725  3662.50  3845.0  4002.00  4276.200\n   160  3600.800  3980.75  4111.5  4236.25  4415.075\n   170  4194.950  4344.75  4421.0  4495.25  4636.025\n   180  4332.000  4487.00  4555.5  4627.00  4758.025\n   190  4530.975  4659.00  4737.0  4809.00  4934.000\n   200  4601.000  4749.75  4831.0  4904.25  5041.125\n   210  4671.000  4831.00  4910.5  4987.00  5120.000\n   220  4748.975  4917.00  4989.5  5061.00  5205.000\n   230  4909.950  5036.00  5088.0  5153.25  5287.025\n   240  5546.950  5633.00  5674.0  5720.00  5836.050\n   250  5644.000  5732.00  5787.0  5845.00  5965.025\n   260  5712.975  5819.75  5880.5  5935.00  6028.000\n   270  5820.925  5939.00  5987.5  6031.25  6115.000\n   280  6289.975  6480.75  6601.5  6797.00  7249.150\n   290  6538.950  6951.25  7134.5  7305.25  7525.050\n   300  7503.000  7622.75  7692.0  7773.25  8034.050\n   310  7646.000  7845.00  7971.0  8096.00  8371.050\n   320  7803.925  8075.75  8220.5  8353.25  8571.050\n   330  8102.825  8396.00  8483.0  8576.75  8765.025\n   340  8471.975  8608.75  8688.5  8770.00  8970.325\n   350  8547.000  8705.00  8792.0  8882.00  9073.025\n   360  8629.000  8806.00  8898.0  8984.00  9142.075\n   370  9067.925  9219.00  9294.0  9379.25  9516.050\n   380  9160.000  9312.00  9393.0  9469.00  9641.050\n   390  9217.975  9391.00  9469.0  9554.00  9764.050\n   400  9306.925  9468.75  9545.0  9642.00  9870.050\n   410  9497.950  9644.75  9738.0  9871.25 10117.100\n   420  9646.950  9847.00  9974.0 10107.25 10267.050\n   430  9850.925 10067.75 10259.0 10312.25 10457.050\n   440  9980.900 10172.00 10309.5 10377.25 10534.050\n   450 10414.950 10578.00 10677.0 10796.00 11034.100\n   460 10696.925 10914.75 11027.5 11114.25 11309.100\n   470 11124.850 11518.75 11730.5 11977.50 12415.050\n   480 11568.500 12215.75 12421.0 12560.00 12710.050\n   490 12762.000 12867.00 12924.0 12980.00 13124.000\n   500 12927.000 13052.00 13119.0 13199.00 13376.025\n   510 13324.950 13506.75 13597.0 13711.25 13915.025\n\n\n\n\n\nplot(SlugganOut)\n\n\n\n\n\n\n\nA more complete version of the modelling process using Bchron can be found in the vignette.\n\n\n\n\n\n\nResources\n\n\n\nAge-depth modelling is complicated, there are many pitfalls, assumptions, and uncertainties that are often ignored. Recent developments have begun to focus on quantifying uncertainties to understand the reliability of inferences made from the data. Ket papers for understanding age depth modelling include:\n\nBlaauw et al. (2018)\nParnell et al. (2008)\nTrachsel and Telford (2017)"
  },
  {
    "objectID": "03-age-depth-modelling.html#part-2-exercises",
    "href": "03-age-depth-modelling.html#part-2-exercises",
    "title": "4  Age-depth modelling",
    "section": "4.2 Part 2: Exercises",
    "text": "4.2 Part 2: Exercises\nYou may want to refer to the bchron vignette to find some helpful information for the exercises below.\n\n4.2.1 Calibration\n\nUsing the existing example code, change the calCurves input to:\n\nthe Southern Hemisphere calibration curve\nthe marine sediments curve.\n\nCalibrate a different set of three ages by modifying the inputs to ages and ageSds.\n\nThe object you assigned the result of BchronCalibrate to contains all the calibration information and can be accessed with the $ e.g., ages$Date1$ageGrid\n\nUsing one of your calibrated sets of three dates, calculate the median age from the ageGrid and the difference of each calibrated age to the original uncalibrated age.\n\n\n\n\n\n\n\nMedian and mean ages\n\n\n\nCommonly, only the median age is reported; however, it is good practice to report and consider the range of possible ages, especially when exploring synchroneity of events across space. Notice how Bchron focuses on delivering ranges and densities.\n\n\n\n\n4.2.2 Classical age-depth modelling:\n\nBchron has a second built-in dataset named Glendalough. Using the Glendalough dataset:\n\nFit a linear interpolation, linear regression, three different order polynomials and a cubic spline\nPlot the results\n\nDid you run into any errors or warnings? If so, why?\n\n\n\n4.2.3 Bayesian age-depth modelling\n\nRun the Bchron age-depth model on the Glendalough dataset and consider:\n\nHow does uncertainty change between the plot outputs between the Glendalough (a dataset with fewer radiocarbon dates) and Sluggan Moss (a data-rich site)\nRun the summary funcion on the Glendalough model, does the output reflect the plot? Is there smaller uncertainty around samples? Why is interpreting results in the context of the uncertainty important?"
  },
  {
    "objectID": "03-age-depth-modelling.html#learning-outcomes-rephraseexclude",
    "href": "03-age-depth-modelling.html#learning-outcomes-rephraseexclude",
    "title": "4  Age-depth modelling",
    "section": "4.3 Learning outcomes (Rephrase/exclude)",
    "text": "4.3 Learning outcomes (Rephrase/exclude)\n\nLearn how to access and use-built in datasets\nLearn how to find package vignettes"
  },
  {
    "objectID": "04-neotoma2.html#introduction",
    "href": "04-neotoma2.html#introduction",
    "title": "5  The neotoma2 package",
    "section": "5.1 Introduction",
    "text": "5.1 Introduction\nThis series of exercises is designed to give you hands-on practice in using APIs and the neotoma2 R package (Goring et al. 2015), both for practical reasons and for insights into how open-data systems work. The primary purpose of neotoma2 is to pass data from the Neotoma Paleoecology Database (Neotoma DB) server into your local R environment. Neotoma relies on Application Programming Interfaces (APIs) to communicate with the Neotoma Paleoecology Database, so we’ll begin with an introduction to APIs.\nMuch of this exercise is based on A Simple Workflow and A Not so Simple Workflow tutorials that were originally developed for a workshop convened by the European Pollen Database in June 2022. Today we’ll keep the initial analyses relatively simple, so that you can focus on learning the data structures and functions used by neotoma2. A hard-won lesson for a practicing data scientist is how much time and attention goes into data handling!\nIn this tutorial you will learn how to:\n\nUse the Neotoma API\nSearch for sites using site names and geographic parameters\nFilter results using temporal and spatial parameters\nObtain sample information for the selected datasets\nPerform basic analysis including the use of climate data from rasters\n\nThis series of exercises is designed to give you hands-on practice in using APIs and the neotoma2 R package, both for practical reasons and for insights into how open-data systems work. neotoma2’s primary purpose is to pass data from the Neotoma DB server into your local R computing environment. Neotoma relies on Application Programming Interfaces (APIs) to communicate with the Neotoma Paleoecology Database, so we’ll begin with an introduction to APIs."
  },
  {
    "objectID": "04-neotoma2.html#the-wide-wide-world-of-apis",
    "href": "04-neotoma2.html#the-wide-wide-world-of-apis",
    "title": "5  The neotoma2 package",
    "section": "5.2 The Wide, Wide World of APIs",
    "text": "5.2 The Wide, Wide World of APIs\nThe Neotoma Paleoecology Database is a relational database, hosted on servers at Penn State’s Center for Environmental Informatics. For security reasons, direct access to these servers is quite limited, and available only to a few Neotoma and CEI programmers.\nAPIs offer public access points into Neotoma that anyone can use. Each API is basically a function: you provide the API with a set of operational parameters, and it returns a set of data or metadata. Each API hence is designed to support one particular task or set of tasks; it offers a narrow window into the larger Neotoma DB. REST-ful APIs follow a particular set of standards that allow them to be read by web browsers (i.e. within the HTTP protocol) and return data objects, typically in HTML, XML, JSON or other human- & machine-readable formats.\nThe Neotoma APIs provide a series of functions for retrieving different kinds of data from Neotoma DB. Data objects are returned in JSON format. For this exercise, we strongly recommend adding an extension to your browser that formats the JSON output to make it easier to read, such as JSONView for Firefox, and JSON Formatter for Chrome.\nThe APIs for Neotoma can be found here: https://api.neotomadb.org/api-docs/. Look through the lists of different APIs and find the one labeled GET /v2.0/data/sites/{siteid}. Then, click on the Try It Out button at right, enter 666 into the site identifier box, and click Execute. Then scroll down. You should see some example code in curl format (ignore this) and as a URL. If you scroll down further, you’ll see the actual data return, in JSON format. JSON is a structured data format designed to be both human-readable and machine-readable. It looks like a nested series of lists.\nNow, let’s go from the API sandbox to direct use of the API URLs in a browser. Copy and paste the below URL into the URL box in your browser:\nhttps://api.neotomadb.org/v2.0/data/sites?sitename=%devil%\nThis should open a new web page in your browser with a returned JSON object. For this search, the JSON object should include 16 or more sites with the name ‘devil’ in them (note the use of % as wildcards), including Devil’s Lake, WI. The opening line “status” = “success” means that the API ran successfully. Note that it is possible for an API to run successfully but return no data! For example, try:\nhttps://api.neotomadb.org/v2.0/data/sites?sitename=devil\nHere, “status” = “success” but data=[], i.e. the API successfully reported back to you that no sites in Neotoma have the exact name of ‘devil’.\nOnce you know what an API is, you will quickly see how widely these are used by modern browsers and websites. For example, try:\nhttps://www.google.com/search?q=neotoma&ei=-xE_Y4XHA8GF0PEPi6-p-AU&ved=0ahUKEwjFsPSAksz6AhXBAjQIHYtXCl8Q4dUDCA0&uact=5&oq=neotoma&gs_lcp=Cgdnd3Mtd2l6EAMyDgguEIAEEIsDEKgDEJ4DMggILhCABBCLAzIICC4QgAQQiwMyCAguEIAEEIsDMggILhCABBCLAzIICAAQkQIQiwMyCAguEIAEEIsDMggILhCABBCLAzIICC4QgAQQiwMyCAgAEIAEEIsDOgoIABBHENYEELADOgcIABCwAxBDOg0IABDkAhDWBBCwAxgBOgwILhDIAxCwAxBDGAI6DwguENQCEMgDELADEEMYAjoOCC4QgAQQxwEQ0QMQ1AI6CwgAEIAEELEDEIMBOhEILhCABBCxAxCDARDHARDRAzoOCC4QgAQQsQMQgwEQ1AI6FAguEIAEELEDEIMBENQCEJsDEKgDOg4ILhCABBDHARDRAxCLAzoOCAAQgAQQsQMQgwEQiwM6EQguEIAEENQCEIsDEKgDEKQDOg4IABCRAhCLAxCmAxCoAzoNCAAQQxCLAxCoAxCmAzoFCAAQgAQ6CAguELEDEIMBOgsILhCABBDHARCvAToHCAAQQxCLAzoICC4QgAQQsQM6CAgAEIAEELEDOhEILhCABBCxAxDUAhCjAxCoAzoLCC4QsQMQgwEQiwM6BwgAEIAEEAo6DggAELEDEIMBEJECEIsDOhAIABCABBCxAxCDARAKEIsDOgoIABCABBAKEIsDOgUIABCRAkoECEEYAEoECEYYAVC5BVirCmDFDGgBcAF4AIABjAGIAdcFkgEDMy40mAEAoAEByAERuAEDwAEB2gEGCAEQARgJ2gEGCAIQARgI&sclient=gws-wiz\nNote that in this demo use of the Google search API, all we did is enter ‘neotoma’ in the standard Google search window and then Google produced and formatted the above API query with a ?search parameter (and who knows what else is lurking in that massive text parameter…)\nOK, now your turn:\nExercise Question 1 Use the sites API to retrieve site data for sites of interest. The sites API has a few different parameters, so try out options. Try copying and pasting the URLs into the address line of your browser, and then hitting return. In your homework exercise, provide at least two sites API calls (as URLs) with a comment line for each that explains what the API command is doing."
  },
  {
    "objectID": "04-neotoma2.html#getting-started-with-neotoma2",
    "href": "04-neotoma2.html#getting-started-with-neotoma2",
    "title": "5  The neotoma2 package",
    "section": "5.3 Getting Started With neotoma2",
    "text": "5.3 Getting Started With neotoma2\nFor this workbook we use several packages, including leaflet, sf and others. We load the packages using the pacman package, which will automatically install the packages if they do not currently exist in your set of packages.\n\n\n\n\n\n\nPackages required for this section\n\n\n\nneotoma2 is available from GitHub and can be installed in R using the devtools package via:\n\n# Load up the package\nif (!require(\"pacman\")) install.packages(\"pacman\", repos=\"http://cran.r-project.org\")\npacman::p_load(dplyr, ggplot2, sf, geojsonsf, leaflet, raster, DT, devtools) # devtools allows us to install from online repositories\n\n\n\n\n5.3.1 Good coding practice: explicitly naming packages and functions\nDifferent packages in R are created independently by different teams of developers, and it’s very common for two different packages to use the same function names (the English language is finite…). This can lead to coding errors if you call a function that you know is in one package, but R guesses wrongly that you wanted a function of the same name from an entirely different package. For example, for a function like filter(), which exists in both neotoma2 and other packages such as dplyr, you may see an error that looks like:\nError in UseMethod(\"filter\") :\n no applicable method for 'filter' applied to an object of class \"sites\"\nYou can avoid this error by explicitly naming which package has the function that you want to use, through the standard convention of double colons (package.name::function.name). For example, using neotoma2::filter() tells R explicitly that you want to use the filter() function in the neotoma2 package, not some other package version.\nSummary: It’s good coding practice to always explicitly link packages to the functions that you are using! Your future self will thank you.\n\n\n5.3.2 Getting Help with Neotoma (APIs, R, Explorer, Tilia, …)\nFor Geog523, the class Slack workspace is your first and best option. If you’re planning on working with Neotoma more in the future, please join us on Slack, where we manage a channel specifically for questions about the R package. You may also wish to join Neotoma’s Google Groups mailing list, and if so contact us to be added."
  },
  {
    "objectID": "05-wrangling-visualisation.html",
    "href": "05-wrangling-visualisation.html",
    "title": "6  Data wrangling and visualisations",
    "section": "",
    "text": "Data checks\nTidying data\nPlotting data"
  },
  {
    "objectID": "06-exploratory-analyses.html",
    "href": "06-exploratory-analyses.html",
    "title": "7  Exploratory Analyses",
    "section": "",
    "text": "Basic descriptors of palaeoecological data"
  },
  {
    "objectID": "07-dissimilarity-roc.html",
    "href": "07-dissimilarity-roc.html",
    "title": "8  Dissimilarity and Rates of Change",
    "section": "",
    "text": "Here is an equation.\n\\[\\begin{equation}\n  f\\left(k\\right) = \\binom{n}{k} p^k\\left(1-p\\right)^{n-k}\n  (\\#eq:binom)\n\\end{equation}\\]"
  },
  {
    "objectID": "08-no-analogue.html",
    "href": "08-no-analogue.html",
    "title": "9  Novelty and No Analogue Futures",
    "section": "",
    "text": "Jack"
  },
  {
    "objectID": "09-ordination-pca.html",
    "href": "09-ordination-pca.html",
    "title": "10  Ordination: Principal Component Analysis",
    "section": "",
    "text": "Principal Component Analysis (PCA) is a statistical method for reducing \\(n\\)-dimensional data (e.g., the \\(n\\) species in your data) to fewer axes that minimise the variance in the data."
  },
  {
    "objectID": "10-ordination-nmds.html",
    "href": "10-ordination-nmds.html",
    "title": "11  Ordination: Non-metric Dimension Scaling",
    "section": "",
    "text": "I need wifi."
  },
  {
    "objectID": "11-gams.html#hierarchical-generalised-additive-models.",
    "href": "11-gams.html#hierarchical-generalised-additive-models.",
    "title": "12  Generalised Additive Models",
    "section": "12.1 Hierarchical Generalised Additive Models.",
    "text": "12.1 Hierarchical Generalised Additive Models."
  },
  {
    "objectID": "12-tapas.html",
    "href": "12-tapas.html",
    "title": "13  Charcoal Analysis using TAPAS",
    "section": "",
    "text": "Tapas is a R package for analysing charcoal"
  },
  {
    "objectID": "13-psm.html",
    "href": "13-psm.html",
    "title": "14  Proxy System Modelling",
    "section": "",
    "text": "Should this be replaced with LDA/CTM?"
  },
  {
    "objectID": "15-test-chapter.html",
    "href": "15-test-chapter.html",
    "title": "15  Test pad to delete",
    "section": "",
    "text": "Sandbox chapter for testing scripts outside main writing if necessary\n\n\n\n\n\n\nPackages required for this section\n\n\n\nList of packages required for section and what they are used for\n\n\n\n\n\n\n\n\nRespawn code\n\n\n\nBegin each section with a code-block that can be run to reproduce the necessary data format for the upcoming section\n\n\n\n\n\n\n\n\nOh no! 😱\n\n\n\nExample of common mistakes 😱\n\n\n\n\n\n\n\n\nGood practice tip\n\n\n\nTips on version control, directory structure (and anything else) that make life easier\n\n\n\n\n\n\n\n\nResources\n\n\n\nList of packages required for section and what they are used for"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Blaauw, Maarten, J. Andrés Christen, K. D. Bennett, and Paula J. Reimer.\n2018. “Double the Dates and Go for Bayes\nImpacts of Model Choice, Dating Density and Quality on\nChronologies.” Quaternary Science Reviews 188 (May):\n58–66. https://doi.org/10.1016/j.quascirev.2018.03.032.\n\n\nBlois, Jessica L., John W. (Jack) Williams, Eric C. Grimm, Stephen T.\nJackson, and Russell W. Graham. 2011. “A Methodological Framework\nfor Assessing and Reducing Temporal Uncertainty in Paleovegetation\nMapping from Late-Quaternary Pollen Records.”\nQuaternary Science Reviews 30 (15-16): 1926–39. https://doi.org/10.1016/j.quascirev.2011.04.017.\n\n\nGoring, S., J. W. Williams, J. L. Blois, S. T. Jackson, C. J. Paciorek,\nR. K. Booth, J. R. Marlon, M. Blaauw, and J. A. Christen. 2012.\n“Deposition Times in the Northeastern United States\nDuring the Holocene: Establishing Valid Priors for\nBayesian Age Models.” Quaternary Science\nReviews 48 (August): 54–60. https://doi.org/10.1016/j.quascirev.2012.05.019.\n\n\nMottl, Ondřej, Suzette G. A. Flantua, Kuber P. Bhatta, Vivian A. Felde,\nThomas Giesecke, Simon Goring, Eric C. Grimm, et al. 2021. “Global\nAcceleration in Rates of Vegetation Change over the Past 18,000\nYears.” Science 372 (6544): 860–64. https://doi.org/10.1126/science.abg1685.\n\n\nParnell, A. C., J. Haslett, J. R. M. Allen, C. E. Buck, and B. Huntley.\n2008. “A Flexible Approach to Assessing Synchroneity of Past\nEvents Using Bayesian Reconstructions of Sedimentation\nHistory.” Quaternary Science Reviews 27 (19-20):\n1872–85. https://doi.org/10.1016/j.quascirev.2008.07.009.\n\n\nReimer, Paula J, William E N Austin, Edouard Bard, Alex Bayliss, Paul G\nBlackwell, Christopher Bronk Ramsey, Martin Butzin, et al. 2020.\n“The IntCal20 Northern Hemisphere Radiocarbon Age\nCalibration Curve (0 Cal kBP).” Radiocarbon 62 (4): 725–57.\nhttps://doi.org/10.1017/RDC.2020.41.\n\n\nSmith, A. G., and I. C. Goddard. 1991. “A 12500 Year\nRecord of Vegetational History at Sluggan\nBog, Co. Antrim, N.\nIreland (Incorporating a Pollen Zone\nScheme for the Non-Specialist).” The New\nPhytologist 118 (1): 167–87.\n\n\nTrachsel, Mathias, and Richard J Telford. 2017. “All Agedepth\nModels Are Wrong, but Are Getting Better.” The Holocene\n27 (6): 860–69. https://doi.org/10.1177/0959683616675939."
  },
  {
    "objectID": "03-age-depth-modelling.html",
    "href": "03-age-depth-modelling.html",
    "title": "4  Age-depth modelling",
    "section": "",
    "text": "References"
  },
  {
    "objectID": "04-neotoma2.html#neotoma2-site-searches-get_sites",
    "href": "04-neotoma2.html#neotoma2-site-searches-get_sites",
    "title": "5  The neotoma2 package",
    "section": "5.4 Neotoma2: Site Searches: get_sites()",
    "text": "5.4 Neotoma2: Site Searches: get_sites()\nMany users of Neotoma first want to search and explore data at the site level. There are several ways to find sites in neotoma2, but we think of sites primarily as spatial objects. They have names, locations, and are found within geopolitical units. However, sites themselves do not have associated information about taxa, dataset types, or ages. sites instead are simply the container into which we add that information. So, when we search for sites we can search by:\n\nsiteid\nsitename\nlocation\naltitude (maximum and minimum)\ngeopolitical unit\n\n\n5.4.0.1 Searching by Site Name: sitename=\"%Devil%\"\nWe may know exactly what site we’re looking for (“Devil’s Lake”), or have an approximate guess for the site name (for example, we know it’s something like “Devil Pond”, or “Devil’s Hole”).\nWe use the general format: get_sites(sitename=\"XXXXX\") for searching by name.\nPostgreSQL (and the API) uses the percent sign as a wildcard. So \"%Devil%\" would pick up “Devils Lake” for us (and would pick up “Devil’s Canopy Cave”). Note that the search query is case insensitive, so \"%devil%\" will work.\nIf we want an individual record we can use the siteid, which is a unique identifier for each site: .\n\n5.4.0.1.1 Code\n\ndevil_sites <- neotoma2::get_sites(sitename = \"%Devil%\")\nplotLeaflet(devil_sites)\n\n\n\n5.4.0.1.2 Result\n\n\n\n\n\n\n\n\n\n5.4.1 \nExercise Question 2 How many sites have the name ‘clear’ in them? Show both your code and provide the total count.\n\n5.4.1.1 Searching by Location: loc=c()\nThe neotoma package used a bounding box for locations, structured as a vector of latitude and longitude values: c(xmin, ymin, xmax, ymax). The neotoma2 R package supports both this simple bounding box and also more complex spatial objects, using the sf package. Using the sf package allows us to more easily work with raster and polygon data in R, and to select sites using more complex spatial objects. The loc parameter works with the simple vector, WKT, geoJSON objects and native sf objects in R. Note however that the neotoma2 package is a wrapper for a simple API call using a URL (see APIs above), and URL strings have a maximum limit of 1028 characters, so the API currently cannot accept very long/complex spatial objects.\nAs an example of different ways that you can search by location, let’s say you wanted to search for all sites in the state of Michigan. Here are three spatial representations of Michigan: 1) a geoJSON list with five elements, 2) WKT, and 3) bounding box representation. And, as a fourth variant, we’ve transformed the mich$geoJSON element to an object for the sf package. Any of these four spatial representations work with the neotoma2 package.\n\nmich <- list(geoJSON = '{\"type\": \"Polygon\",\n        \"coordinates\": [[\n            [-86.95, 41.55],\n            [-82.43, 41.55],\n            [-82.43, 45.88],\n            [-86.95, 45.88],\n            [-86.95, 41.55]\n            ]]}',\n        WKT = 'POLYGON ((-86.95 41.55,\n                         -82.43 41.55,\n                         -82.43 45.88,\n                         -86.95 45.88,\n                         -86.95 41.55))',\n        bbox = c(-86.95, 41.55, -82.43, 45.88))\n\nmich$sf <- geojsonsf::geojson_sf(mich$geoJSON)[[1]]\n\nmich_sites <- neotoma2::get_sites(loc = mich$geoJSON, all_data = TRUE)\n\nYou can always simply plot() the sites objects, but this won’t show any geographic context. The leaflet::plotLeaflet() function returns a leaflet() map, and allows you to further customize it, or add additional spatial data (like our original bounding polygon, mich$sf, which works directly with the R leaflet package):\n\n5.4.1.1.1 Code\n\nneotoma2::plotLeaflet(mich_sites) %>%\n  leaflet::addPolygons(map = .,\n                       data = mich$sf,\n                       color = \"green\")\n\n\n\n5.4.1.1.2 Result\n\n\n\n\n\n\n\n\n\n\n5.4.2 \nExercise Question 3 Which state has more sites in Neotoma, Minnesota or Wisconsin? How many in each state? Provide both code and answer.\n\n5.4.2.1 Helper Functions for Site Searches\n\n\n\nNeotoma R Package Universal Modeling Language (UML) diagram.\n\n\nIf we look at the UML diagram for the objects in the neotoma2 R package, we can see that there are a set of functions that can operate on sites. As we add to sites objects, using get_datasets() or get_downloads(), we are able to use more of these helper functions. We can use functions like summary() to get a more complete sense of the types of data in this set of sites.\nThe following code gives the summary table. We do some R magic here to change the way the data is displayed (turning it into a datatable() object using the DT package), but the main function is the summary() call.\n\n5.4.2.1.1 Code\n\nneotoma2::summary(mich_sites)\n\n\n\n5.4.2.1.2 Result\n\n\n\n\n\n\n\n\n\n\n\n5.4.3 \nWe can see that there are no chronologies associated with the site objects. This is because, at present, we have not pulled in the dataset information we need. All we know from get_sites() are the kinds of datasets we have.\n\n\n5.4.4 Searching for Datasets:\nNow that we know how to search for sites, we can start to search for datasets. As we’ve discussed before, in the Neotoma data model, each site can contain one or more collection units, each of which can contain one or more datasets. Similarly, a sites object contains collectionunits which contain datasets. From the table above, we can see that some of the sites we’ve looked at contain pollen data. However, so far we have only downloaded the sites data object and not any of the actual pollen data, it’s just that (for convenience) the sites API returns some information about datasets, to make it easier to navigate the records.\nWith a sites object we can directly call get_datasets(), to pull in more metadata about the datasets. At any time we can use datasets() to get more information about any datasets that a sites object may contain. Compare the output of datasets(mich_sites) to the output of a similar call using the following:\n\n5.4.4.1 Code\n\nmich_datasets <- neotoma2::get_datasets(mich_sites, all_data = TRUE)\n\ndatasets(mich_datasets)\n\n\n\n5.4.4.2 Result\n\n\n\n\n\n\n\n\n\n\n5.4.5 \nQuestion 4: How many different kinds of datasets are available at Devil’s Lake, WI? Show both code and answer. Ensure that your code just retrieves datasets for just this single site.\n\n\n5.4.6 Filter Records\nIf we choose to pull in information about only a single dataset type, or if there is additional filtering we want to do before we download the data, we can use the filter() function. For example, if we only want pollen records, and want records with known chronologies, we can filter:\n\n5.4.6.1 Code\n\nmich_pollen <- mich_datasets %>%\n  neotoma2::filter(datasettype == \"pollen\" & !is.na(age_range_young))\n\nneotoma2::summary(mich_pollen)\n\n\n\n5.4.6.2 Result\n\n\n\n\n\n\n\n\n\n\n5.4.7 \nNote, that we are filtering on two conditions. (You may want to look up the operators being used in the above code: ==, &, and ! to understand what they accomplish in the code.) We can see now that the data table looks different, and there are fewer total sites.\n\n\n5.4.8 Retrieving sample() data.\nThe sample data are the actual data that scientists usually want - counts of pollen grains, lists of vertebrate fossil occurrences, etc. Because sample data can have fairly large data volumes (each dataset may contain many samples), which can strain server bandwidth and local computing memory, we try to call get_downloads() after we’ve done our preliminary filtering. After get_datasets(), you have enough information to filter based on location, time bounds, and dataset type. When we move to get_downloads() we can do more fine-tuned filtering at the analysis unit or taxon level.\nThe following command may take a few moments to run. (If it takes too long, we have stored an already-downloaded version of the function output as an RDS data file that you can load directly into R.)\n\nmich_dl <- mich_pollen %>% get_downloads(all_data = TRUE)\n\n...........................\n\n# mich_dl <- readRDS('data/mich_dl.rds')\n\nOnce we’ve downloaded the sample data, we now have information for each site about all the associated collection units, the datasets, and, for each dataset, all the samples associated with the datasets. To extract all the samples we can call:\n\nallSamp <- samples(mich_dl)\n\nWhen we’ve done this, we get a data.frame that is 38062 rows long and 37 columns wide. The reason the table is so wide is that we are returning data in a long format. Each row contains all the information you should need to properly interpret it:\n\n\n [1] \"age\"             \"agetype\"         \"ageolder\"        \"ageyounger\"     \n [5] \"chronologyid\"    \"chronologyname\"  \"units\"           \"value\"          \n [9] \"context\"         \"element\"         \"taxonid\"         \"symmetry\"       \n[13] \"taxongroup\"      \"elementtype\"     \"variablename\"    \"ecologicalgroup\"\n[17] \"analysisunitid\"  \"sampleanalyst\"   \"sampleid\"        \"depth\"          \n[21] \"thickness\"       \"samplename\"      \"datasetid\"       \"siteid\"         \n[25] \"sitename\"        \"lat\"             \"long\"            \"area\"           \n[29] \"sitenotes\"       \"description\"     \"elev\"            \"collunitid\"     \n[33] \"database\"        \"datasettype\"     \"age_range_old\"   \"age_range_young\"\n[37] \"datasetnotes\"   \n\n\nFor some dataset types, or analyses some of these columns may not be needed, however, for other dataset types they may be critically important. To allow the neotoma2 package to be as useful as possible for the community we’ve included as many as we can.\n\n5.4.8.1 Extracting Taxa\nIf you want to know what taxa we have in a dataset, you can use the helper function taxa() on the sites object. The taxa() function gives us, not only the unique taxa, but two additional columns, sites and samples, that tell us how many sites the taxa appear in, and how many samples the taxa appear in, to help us better understand how common individual taxa are.\n\n5.4.8.1.1 Code\n\nneotomatx <- neotoma2::taxa(mich_dl)\n\n\n\n5.4.8.1.2 Results\n\n\n\n\n\n\n\n\n\n\n\nThe taxonid values can be linked to the taxonid column in the samples(). This allows us to build taxon harmonization tables if we choose to. Note also that the taxonname is in the field variablename. Individual sample counts are reported in Neotoma as variables. A “variable” may be either a species for which we have presence or count data, a geochemical measurement, or any other proxy, such as charcoal counts. Each stored entry for a variable includes the units of measurement and the value.\n\n\n5.4.8.2 Taxonomic Harmonization (Simple)\nA standard challenge in Neotoma (and in biodiversity research more generally) is that different scientists use different names for taxonomic entities such as species. Even if everyone agrees on a common taxonomy, it’s quite possible that a given fossil might be only partially identifiable, perhaps just to genus or even family. Hence, when working with data from Neotoma, a common intermediary step is to ‘harmonize’ all the taxa names stored in Neotoma into some standard names of interest to you.\nLet’s say we want to know the past distribution of Pinus. We want all the various pollen morphotypes that are associated with Pinus (e.g. Pinus strobus, Pinus strobus-type, Pinus undif., Pinus banksiana/resinosa) to be grouped together into one aggregated taxon names called Pinus. There are several ways of doing this, either directly by exporting the file and editing each individual cell, or by creating an external “harmonization” table.\nProgrammatically, we can harmonize all the taxon names using matching and transformation. We’re using dplyr type coding here to mutate() the column variablename so that any time we detect (str_detect()) a variablename that starts with Pinus (the .* represents a wildcard for any character [.], zero or more times [*]) we replace() it with the character string \"Pinus\". Note that this changes Pinus in the allSamp object, but if we were to call samples() again, the taxonomy would return to its original form.\nAs a first step, we’re going to filter the ecological groups to include only UPHE (upleand/heath) and TRSH (trees and shrubs). (More information about ecological groups is available from the Neotoma Online Manual.) After converting all _Pinus._ records to Pinus* we then sum the counts of the Pinus records.\n\nallSamp <- allSamp %>%\n  dplyr::filter(ecologicalgroup %in% c(\"UPHE\", \"TRSH\")) %>%\n  mutate(variablename = replace(variablename,\n                                stringr::str_detect(variablename, \"Pinus.*\"),\n                                \"Pinus\"),\n         variablename = replace(variablename,\n                                stringr::str_detect(variablename, \"Picea.*\"),\n                                \"Picea\")) %>%\n  group_by(siteid, sitename,\n           sampleid, variablename, units, age,\n           agetype, depth, datasetid,\n           long, lat) %>%\n  summarise(value = sum(value), .groups='keep')\n\nThere were originally 6 different taxa identified as being within the genus Pinus (including Pinus, Pinus subg. Pinus, and Pinus undiff.). The above code reduces them all to a single taxonomic group Pinus. We can check out the unique names by using:\n\n5.4.8.2.1 Code\n\nneotomatx %>%\n  ungroup() %>%\n  filter(stringr::str_detect(variablename, \"Pinus\")) %>%\n  summarise(pinus_spp = unique(variablename))\n\n# I actually like Base here for the one-liner:\n# unique(grep(\"Pinus\", neotomatx$variablename, value = TRUE))\n\n\n\n5.4.8.2.2 Result\n\n\n\n\n\n\n\n\n\n\n\nQuestion 5: Follow the Pinus example above, but now for Picea. How many taxon names were aggregated into your Picea name?\nIf we want to store a record of our choices outside of R, we can use an external table. For example, a table of pairs (what we want changed, and the name we want it replaced with) can be generated, and it can include regular expressions (if we choose):\n\n\n\noriginal\nreplacement\n\n\n\n\nAbies.*\nAbies\n\n\nVaccinium.*\nEricaceae\n\n\nTypha.*\nAquatic\n\n\nNymphaea\nAquatic\n\n\n…\n…\n\n\n\nWe can get the list of original names directly from the taxa() call, applied to a sites object, and then export it using write.csv(). We can also do some exploratory plots of the data:\n\n5.4.8.2.3 Code\n\ntaxaplots <- taxa(mich_dl)\n# Save the taxon list to file so we can edit it subsequently.\nreadr::write_csv(taxaplots, \"data/mytaxontable.csv\")\n\n\n\n5.4.8.2.4 Result\n\n\n\n\n\nFigure. A plot of the number of sites a taxon appears in, against the number of samples a taxon appears in.\n\n\n\n\n\n\n\n\nThe plot is mostly for illustration, but we can see, as a sanity check, that the relationship is as we’d expect."
  },
  {
    "objectID": "04-neotoma2.html#simple-analytics",
    "href": "04-neotoma2.html#simple-analytics",
    "title": "5  The neotoma2 package",
    "section": "5.5 Simple Analytics",
    "text": "5.5 Simple Analytics\n\n5.5.1 Stratigraphic Plotting: Building a Pollen Diagram\nAs you’ve seen already, stratigraphic diagrams are a very common way of viewing geological data, in which time is represented vertically and with older materials at bottom, just like in the sediment record. Palynologists use a particular form of a stratigraphic diagram called a pollen diagram.\nWe can use packages like rioja to do stratigraphic plotting for a single dataset. Here, we’ll take a few key species at a single site and plot them.\n\n# Get a particular site, select only taxa identified from pollen (and only trees/shrubs)\n# Transform to proportion values.\ndevils_samples <- get_sites(siteid = 666) %>%\n  get_downloads() %>%\n  samples()\n\n.....\n\ndevils_samples <- devils_samples %>%\n  mutate(variablename = replace(variablename,\n                                stringr::str_detect(variablename, \"Pinus.*\"),\n                                \"Pinus\")) %>%\n  group_by(siteid, sitename,\n           sampleid, variablename, units, age,\n           agetype, depth, datasetid,\n           long, lat) %>%\n  summarise(value = sum(value), .groups='keep')\n\n\nonesite <- devils_samples %>%\n  group_by(age) %>%\n  mutate(pollencount = sum(value, na.rm = TRUE)) %>%\n  group_by(variablename) %>%\n  mutate(prop = value / pollencount) %>%\n  arrange(desc(age))\n\n# Spread the data to a \"wide\" table, with taxa as column headings.\nwidetable <- onesite %>%\n  dplyr::select(age, variablename, prop) %>%\n  mutate(prop = as.numeric(prop))  %>%\n  filter(variablename %in% c(\"Pinus\", \"Betula\", \"Quercus\",\n                             \"Tsuga\", \"Ulmus\", \"Picea\"))\n\ncounts <- tidyr::pivot_wider(widetable,\n                             id_cols = age,\n                             names_from = variablename,\n                             values_from = prop,\n                             values_fill = 0)\n\nThis appears to be a fairly long set of commands, but the code is pretty straightforward, and it provides you with significant control over the taxa for display, units pf measurement, and other elements of your data before you get them into the wide matrix (depth by taxon) that most statistical tools such as the vegan package or rioja use. To plot we can use rioja’s strat.plot(), sorting the taxa using weighted averaging scores (wa.order). We’ve also added a CONISS plot to the edge of the plot, to show how the new wide data frame works with distance metric functions. (We’ll talk more about distance and dissimilarity metrics in upcoming labs.)\n\nclust <- rioja::chclust(dist(sqrt(counts)),\n                        method = \"coniss\")\n\nplot <- rioja::strat.plot(counts[,-1] * 100, yvar = counts$age,\n                  title = devils_samples$sitename[1],\n                  ylabel = \"Calibrated Years BP\",\n                  xlabel = \"Pollen (%)\",\n                  y.rev = TRUE,\n                  clust = clust,\n                  wa.order = \"topleft\", scale.percent = TRUE)\n\nrioja::addClustZone(plot, clust, 4, col = \"red\")\n\n\n\n\nQuestion 5: Make a stratigraphic pollen diagram in rioja, for a site of your choice (not Devils Lake) and taxa of your choice. Show code and resulting diagram.\n\n\n5.5.2 Change Taxon Distributions Across Space and Time\nThe true power of Neotoma is its ability to support large-scale analyses across many sites, many s time periods within sites, many proxies, and many taxa. As a first dipping of our toes in the water, lets look at temporal trends in abundance when averaged across ites. We now have site information across Michigan, with samples, and with taxon names. Let’s say we are interested in looking at the distributions of the selected taxa across time, their presence/absence:\n\ntaxabyage <- allSamp %>%\n  filter(variablename %in% c(\"Pinus\", \"Betula\", \"Quercus\",\n                             \"Tsuga\", \"Ulmus\", \"Picea\"),\n                             age < 11000) %>%\n  group_by(variablename, \"age\" = round(age * 2, -3) / 2) %>%\n  summarise(n = length(unique(siteid)), .groups = 'keep')\n\nsamplesbyage <- allSamp %>%\n  filter(variablename %in% c(\"Pinus\", \"Betula\", \"Quercus\",\n                             \"Tsuga\", \"Ulmus\", \"Picea\")) %>%\n  group_by(\"age\" = round(age * 2, -3) / 2) %>%\n  summarise(samples = length(unique(siteid)), .groups = 'keep')\n\ngroupbyage <- taxabyage %>%\n  inner_join(samplesbyage, by = \"age\") %>%\n  mutate(proportion = n / samples)\n\nggplot(groupbyage, aes(x = age, y = proportion)) +\n  geom_point() +\n  geom_smooth(method = 'gam',\n              method.args = list(family = 'binomial')) +\n  facet_wrap(~variablename) +\n  #coord_cartesian(xlim = c(22500, 0), ylim = c(0, 1)) +\n  scale_x_reverse() +\n  xlab(\"Proportion of Sites with Taxon\") +\n  theme_bw()\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n\n\n\n\n\nWe can see clear patterns of change for at least some taxa, and the smoothed surfaces are modeled using Generalized Additive Models (GAMs) in R, so we can have more or less control over the actual modeling using the gam or mgcv packages. Depending on how we divide the data we can also look at shifts in altitude, latitude or longitude to better understand how species distributions and abundances changed over time in this region.\nNote that for some taxa, they always have a few pollen grains in all pollen samples, so this ‘proportion of sites with taxon’ isn’t very informative. Calculating a metric like average abundance might be more useful.\nQuestion 6: Repeat the above example, for a different state or other geographic region of your choice."
  },
  {
    "objectID": "04-neotoma2.html#conclusion",
    "href": "04-neotoma2.html#conclusion",
    "title": "5  The neotoma2 package",
    "section": "5.6 Conclusion",
    "text": "5.6 Conclusion\nSo, we’ve done a lot in this exercise. We’ve (1) learned how APIs work (2) searched for sites using site names and geographic parameters, (3) filtered results using temporal and spatial parameters, (4) built a pollen diagram, and (5) done a first-pass spatial mapping of taxa. We will build upon this methodological foundation in future lab exercises.\n\n\n\n\nGoring, Simon, Andria Dawson, Gavin Simpson, Karthik Ram, Russ Graham, Eric Grimm, and John Williams. 2015. “Neotoma: A Programmatic Interface to the Neotoma Paleoecological Database.” Open Quaternary 1 (1): Art. 2. https://doi.org/10.5334/oq.ab."
  }
]